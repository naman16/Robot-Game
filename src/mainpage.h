/**
 * @copyright 2017 3081 Staff, All rights reserved.
 */

#ifndef SRC_MAINPAGE_H_
#define SRC_MAINPAGE_H_
/*! \mainpage CSCI3081W Project
 *
 * \section Iteration-1
 *
 *
 * ## Design Document


For this document, I am walking down each requirement for the iteration and highlighting my rationale for making those design choices: <br/>
Initially, the same function was adding bases and obstacles to the arena but I have changed this to having separate method for adding the bases and obstacles. The primary reason for doing this is that obstacles and bases have different features and characteristics, for example, obstacles become mobile while bases remain immobile and they behave differently in the context of the game. To use the same add function for entities that have different behavior can make things confusing. Keeping this change in mind, I have seperate methods for adding obstacles and bases.
<br/>
Every time a key is pressed to move the robot in the arena, it is accepted as a command by the GraphicsArenaViewer and then this comand is communicated to Controller, the mediator between Arena and GraphicsArenaViewer. Controller then accepts these communications and converts them into the form understandable by Arena and then dispatches it to Arena. Then finally depending upon the communication relayed to it, Arena calls the appropriate robot functions to adjust the velocity. The arrow key presses are intepreted using the GLFW macros by GraphicsArenaViewer. Furthermore, the velocity of the robot cannot be increased/ decreased indefinitely and this is ensured by the methods defined within the robot class to deal with velocity changes. For dealing with all of the communications, I am using state machines in Arena, Controller and GraphicsArenaViewer which depending on the message/communication, updates the arena. <br/>
After each timestep update of the arena and its entities, a check is being made for every mobile entity to see if it is has collided with any other entity or the wall. If there is a collision, the colliding mobile entity calls the HandleCollision method within its own class to deal with the situation. In other words, collisions of robots are handled within robot class and collisions for obstacles are handled within the obstacle class. The reason for dealing with collisions seperately is that the reaction to collisions for robots and obstacles are unique to themselves. When a robot undergoes a collision with a base, the base changes color to denote it has been captured but when the robot collides with obstacles and the walls, it must lose a life. Moreover, on collision with the obstacles,  the robot is given a window of a few(2) seconds to recover (mercy invincibility) and in order to denote this, the robot's color is continuously blinking for that amount of time. But obstacle collisions are handled differently. When an obstacle collides, then it has to reverse in an for a fixed amount of time before it starts moving forward so that it can orient itself back towards the centre of the arena. <br/>
The robot wins when it captures all the bases but loses when it runs out of lives. When we have the game result, the game_status_ is changed to the result of the game. GraphicsArenaViewer houses the primary driver for state change in the arena. This driver calls the method in Controller that is responsible for advancing time for the entire arena. The Controller checks the game_status_ everytime it advances time. When the controller knows that there is a game result, the controller communicates this to the GraphicsArenaViewer which pauses the primary driver and proceeds to displaying the result of the game. The game at that point is over and the result is displayed. Results are being displayed on a button in the graphics window and this button has no functionality, so when it is pressed, nothing happens. Another thing that happens when the game is over is a button displaying "New Game" appears in the window and when this button is pressed, it resets the arena to a new start state. When "New Game" is pressed, the command is sent by the GraphicsArenaViewer to the Controller and the Controller then accepts this command and upon interpreting it, sends it to the Arena which then creates a new start state. <br/>
Starting off, the obstacles were immobile and were inheriting from Arena_Immobile_Entity but now the obstacles need to be made mobile hence we change the relationship and make Obstacles inherit from ArenaMobileEntity. Moreover, when creating Obstacles, we give them a velocity and set the wheel speed for left and right to be the same so that it can move in a straight line. Now that obstacles are mobile, their behavior changes and at every timestep update, their positions are updated according to their velocity, current position and heading angle. Due to mobility, obstacles also need to Handle Collisions and their reaction to collision is different from robots as mentioned above. As a result, collisions of robots are being dealt with seperately within the Obstacle class. Since obstacles are now mobile, their position and velocity are updated very similarly to robot. Obstacle behavior when it undergoes collision is unique and so is its movement (arc movement) when it suffers collision. Keeping in mind this uniqueness(pertaining to obstacles), I deal with both these behaviors inside obstacle class itself. <br/>
In the Graphics Window, I have added a button to deal with playing and pausing the game and to implement this, I am making use of the idea of a state machine. So when the game is being played, the state machine flag is set to false and the button says "Pause". When this button is pressed, the state machine flag becomes true and so the button says "Play" and the game stops until the button is pressed again and the state machine is switched back to false. Hence playing and pausing is being handled within the GraphicsArenaViewer using a state machine. The button that is available in the window at all times is the "New Game" button and everytime this button is pressed, the arena is reset to a new start state in the same way as when the "New Game" button is pressed when the game is over. <br/>
The point of mercy invincibility is to give the robot some time to escape after it has collided with an obstacle and during this period, the robot cannot lose a life. This idea of mercy invincibility is being implemented by using the idea of state machine as well. So when the robot collides with an obstacle, it loses a life but the flag is set to true so that it is known that the robot has entered mercy invincibility time and during this time, all collisions suffered by the robot that could cause it to lose life have to be ignored. When approximately 2 seconds have elapsed, the flag is set to false again and the robot changes color back to the initial color to denote that the mercy invincibility period is over and the robot can once again lose life on colliding. For visual representation of mercy invincibility, the robot is switching colors quickly for that time and this flickering of the colors is also implemented using a state machine. <br/>

These are the design choices that I have made while working on iteration 1 of the Project.
 */
#endif  // SRC_MAINPAGE_H_
